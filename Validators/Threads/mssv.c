//@author: James Barrington
#include <stdio.h>
#include <stdlib.h>
#include <semaphore.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <pthread.h>
/*
This is a small program to validate sudoku solutions using multiple proccesses
Takes in 2 command line arguments
The first is the sudoku solution
The second is the maxwait time for the threads
*/
//create shared memory for threads to share
struct sharedMem {
  int mySudoku[9][9];
  int buffer2[11];
  int counter;
};

struct sharedMem mem;
//Create locks 
pthread_mutex_t logLock;
pthread_mutex_t buffer2Lock;
pthread_mutex_t counterLock;

int maxWait=0;
pthread_t tid[9];
int threadNo;
//checkSub: Takes in a 2d array of integers representing the solution
//Validates to ensure that only one of each number between 1-9 inclusive
void* checkSub(void* a)
{
  int invalidSub =0;
  int i;
  int collums=0;
  int rows=0;
  int l;
  int m;
  int j;
  int testArray[9] = {0,0,0,0,0,0,0,0,0};
  int validSub[9] = {0,0,0,0,0,0,0,0,0};
  int numSubs =9;
  int subNo = 0;

  for(m=0;m<9;m++)
  {
    if(m%3==0)
    {
	//Ensure numbers are between 1-9
      for(i=0;i<9;i++)
      {
        if(i%3==0)
        {
          for(collums = m;collums<m +3;collums++)
          {
            for(rows = i;rows<i+3;rows++)
            {
              if(mem.mySudoku[rows][collums]<1 ||mem.mySudoku[rows][collums]>9)
              {
                validSub[subNo]=1;
                invalidSub =1;
              }
              else
              {
                testArray[mem.mySudoku[rows][collums]]++;
                if(testArray[mem.mySudoku[rows][collums]]>1)
                {
                  validSub[subNo]=1;
                  invalidSub =1;
                }
              }
            }
          }
          subNo++;
          for(j=0;j<10;j++)
          {
            testArray[j]=0;
          }
        }
      }
    }

  }
  srand(time(NULL));
  int wait = rand() % maxWait +1;
  //Sleep by maxdelay
  sleep(wait);

  if(invalidSub==1)
  {
    FILE * log;
    pthread_mutex_lock(&logLock);
    log = fopen("log4.txt", "a");
    fprintf(log,"Thread ID %lu: ", tid[10]);
    fprintf(log,"%s ", "sub grids ");
    for(l=0;l<9;l++)
    {
      if(validSub[l]==1)
      {
            numSubs--;
            int actualSub = l +1;
            fprintf(log,"%d ", actualSub);
      }

    }
    fprintf(log,"are invalid \n");
    fclose(log);
    pthread_mutex_unlock(&logLock);
    pthread_mutex_lock(&buffer2Lock);
    mem.buffer2[10] = numSubs;
    pthread_mutex_unlock(&buffer2Lock);
  }

  pthread_mutex_lock(&buffer2Lock);
  mem.buffer2[10] = numSubs;
  pthread_mutex_unlock(&buffer2Lock);

  pthread_mutex_lock(&counterLock);
  mem.counter += numSubs;
  pthread_mutex_unlock(&counterLock);

  pthread_exit(NULL);
}`
//checkRow: takes in a pointer generated by the thread creation
//Validates to ensure that only one of each number between 1-9 inclusive
void* checkRow(void* inName)
{

  int rowNumber = 0;
  int inValidRow = 0;
  int testNum =0;
  int testArray[10] = {0,0,0,0,0,0,0,0,0,0};
  int f = 0;
	//Ensure numbers are between 1-9
  for(testNum=0;testNum < 9;testNum++)
  {
    if(tid[testNum]==pthread_self())
    {
      rowNumber = testNum;
      for(f=0;f<9;f++)
      {
        if(mem.mySudoku[f][testNum]<1 ||mem.mySudoku[f][testNum]>9)
        {
          inValidRow = 1;
        }
        else
        {
          testArray[mem.mySudoku[rowNumber][f]]= testArray[mem.mySudoku[rowNumber][f]]+1;
          if(testArray[mem.mySudoku[rowNumber][f]]>1)
          {
            inValidRow = 1;
          }
        }
      }
    }
  }
  srand(time(NULL));
  int wait = rand() % maxWait +1;
  //Sleep by maxdelay
  sleep(wait);
  if(inValidRow==1)
  {
    FILE * log;
    pthread_mutex_lock(&logLock);
    log = fopen("log4.txt", "a");
    rowNumber++;
    fprintf(log,"Thread ID %lu: row %d is invalid \n", tid[rowNumber], rowNumber);
    fclose(log);
    pthread_mutex_unlock(&logLock);
    rowNumber--;
    pthread_mutex_lock(&buffer2Lock);
    mem.buffer2[rowNumber] = 1;
    pthread_mutex_unlock(&buffer2Lock);
  }
  else
  {
    pthread_mutex_lock(&buffer2Lock);
    mem.buffer2[rowNumber] = 0;
    pthread_mutex_unlock(&buffer2Lock);

    pthread_mutex_lock(&counterLock);
    mem.counter++;
    pthread_mutex_unlock(&counterLock);
  }

  pthread_exit(NULL);
}
//checkCollumn: takes in a pointer generated by the thread creation
//Validates to ensure that only one of each number between 1-9 inclusive
void * checkCollumn(void* point)
{
  int inValidCollumn = 0;
  int validCollumns = 9;
  int validCol[9] = {0,0,0,0,0,0,0,0,0};
  int testNum =0;
  int testArray[9] = {0,0,0,0,0,0,0,0,0};
  int f = 0;
  int y = 0;
	//Ensure numbers are between 1-9
  for(testNum=0;testNum < 9;testNum++)
  {
      for(f=0;f<9;f++)
      {
        if(mem.mySudoku[f][testNum]<1 ||mem.mySudoku[f][testNum]>9 )
        {
          inValidCollumn = 1;
          validCol[testNum] = 1;
        }
        else
        {
			
          testArray[mem.mySudoku[f][testNum]]++;
          if(testArray[mem.mySudoku[f][testNum]]>1)
          {
            inValidCollumn = 1;
            validCol[testNum] = 1;
          }
        }
      }
      for(y =0; y< 10; y++)
      {
        testArray[y] = 0;
      }
    }
  srand(time(NULL));
  int wait = rand() % maxWait +1;
  //Sleep by maxdelay
  sleep(wait);
  //Thread magic happens here
  if(inValidCollumn==1)
  {
    FILE * log;
    pthread_mutex_lock(&logLock);
    log = fopen("log4.txt", "a");
    fprintf(log,"Thread ID %lu: ", tid[9]);
    fprintf(log,"%s ", "collumn ");
    int checkCol;
    for(checkCol=0; checkCol < 9; checkCol++)
    {
      if(validCol[checkCol] ==1)
      {
        int actualCol = checkCol +1;
        fprintf(log,"%d ", actualCol);
        validCollumns--;
      }
    }
    fprintf(log,"are invalid \n");
    fclose(log);
    pthread_mutex_unlock(&logLock);
    pthread_mutex_lock(&buffer2Lock);
    mem.buffer2[9] = validCollumns;
    pthread_mutex_unlock(&buffer2Lock);
  }
  else
  {
    pthread_mutex_lock(&buffer2Lock);
    mem.buffer2[9] = validCollumns;
    pthread_mutex_unlock(&buffer2Lock);
  }
  pthread_mutex_lock(&counterLock);
  mem.counter += validCollumns;
  pthread_mutex_unlock(&counterLock);
  pthread_exit(NULL);
}
//Main
int main(int argc, char**argv)
{
  int i =0;
  int k =0;
  int j =0;
  int m;
  maxWait = atoi(argv[2]);
  for(m=0;m<11;m++)
  {
    mem.buffer2[m] =0;
  }
  //Check for command line arguments
  if (argc==3)
  {
    FILE *myFile = fopen(argv[1],"r");
    if(myFile == NULL)
    {
      perror("error in opening file!");
      return -1;
    }
    else
    {
      for(i=0; i<9;i++)
      {
        for(j=0;j<9;j++)
        {
          if(fscanf(myFile, "%d", &mem.mySudoku[i][j]) ==1)
          {
          }
          else if(feof(myFile))
          {
            printf("Reached End of file!\n" );
            int amount = i * j;
            printf("Added %d numbers \n", amount);
          }
          else
          {
            perror("error reading file!");

            return -1;
          }
        }
      }
    }
  }
  else
  {
      printf("You did not provide a sudoku solution or a max wait time! \n Program will now exit!\n");
      pthread_mutex_destroy(&counterLock);
      pthread_mutex_destroy(&buffer2Lock);
      pthread_mutex_destroy(&logLock);
      exit(1);
  }

  int thread;
  //Create threads
  for(k=0;k<11;k++)
  {

    if(k <9)
    {
      thread = pthread_create(&(tid[k]),NULL,&checkRow,NULL);
    }
    else if(k==9)
    {
      thread = pthread_create(&(tid[k]),NULL,&checkCollumn,NULL);
    }
    else
    {
      thread = pthread_create(&(tid[k]),NULL,&checkSub,NULL);
    }

    if(thread !=0)
    {
      printf("\n Cannot create thread\n");
    }
  }
  //join threads
  for(k=0;k<11;k++)
  {
    pthread_join(tid[k],NULL);
  }

  int l ;
  int actual=0;
  for(l=8;l>-1;l--)
  {
    actual = l+1;
    if(mem.buffer2[l]==0)
    {
      printf("Validation result from thread ID %lu:",tid[l] );
      printf("row %d is valid\n",actual);
    }
    else
    {
      printf("Validation result from thread ID %lu:",tid[l] );
      printf("row %d is invalid\n",actual);
    }
  }

  printf("Validation result from thread ID %lu:",tid[9] );
  printf("%d of 9 collumns are valid\n", mem.buffer2[9] );
  printf("Validation result from thread ID %lu:",tid[10] );
  printf("%d of 9 subgrids are valid\n", mem.buffer2[10] );
  printf("There are %d valid sub-grids ", mem.counter);
  if(mem.counter==27)
  {
    printf(", and thus the solution is valid\n");
  }
  else
  {
    printf(", and thus the solution is invalid\n");
  }
  return 0;
}
